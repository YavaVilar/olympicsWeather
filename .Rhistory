str(resp$hourly[2][[1]], 1)
unlist(resp$hourly[2][[1]], 1)
unnest_data <- function(resp){
tibble(data_heure=unlist(resp$hourly[1][[1]]),
temperature_celsius=unlist(resp$hourly[2][[1]]),
temperature_ressentie_celsius=unlist(resp$hourly[3][[1]]),
precipitation_proba=unlist(resp$hourly[4][[1]]),
precipitation=unlist(resp$hourly[5][[1]]))
}
perform_request(48.85, 3.35) |>  unnest_data() -> y
plot(y$temperature_celsius)
##9
usethis::use_test("unnest_response")
data_test <- y[c(1:5),]
library(testthat)
##############question 10#################
# Función para convertir una dirección en coordenadas GPS
# Definir la función address_to_gps
address_to_gps <- function(location) {
# dataframe temporaire pour utilisation de geocode
df_temp <- data.frame(address = location, stringsAsFactors = FALSE)
# Appel à geocode avec le dataframe temporaire
result <- geocode(
.tbl = df_temp,
address = "address",
method = 'osm',
limit = 1
)
# Vérifie si des coordonnées ont été trouvées
if(nrow(result) > 0 && !is.na(result$lat[1]) && !is.na(result$long[1])) {
return(c(result$lat[1], result$long[1]))
} else {
# Retourne une erreur si aucune coordonnée n'a été trouvée
return("Aucune coordonnée GPS trouvée pour l'adresse fournie.")
}
}
address_to_gps("Paris")
get_forecast <- function(latitude, longitude){
}
get_gps_coordinate <- function(address) {
address_to_gps(address)
}
# Función interna para convertir una dirección en coordenadas GPS
address_to_gps <- function(location) {
# Dataframe temporal para usar con geocode
df_temp <- data.frame(address = location, stringsAsFactors = FALSE)
# Llamada a geocode con el dataframe temporal
result <- geocode(
.tbl = df_temp,
address = "address",
method = 'osm',
limit = 1
)
# Verificar si se encontraron coordenadas
if (nrow(result) > 0 && !is.na(result$lat[1]) && !is.na(result$long[1])) {
return(c(result$lat[1], result$long[1]))
} else {
# Lanzar un error si no se encontraron coordenadas
stop("No se encontraron coordenadas GPS para la dirección proporcionada.")
}
}
# Ejemplo de uso
coordinates <- get_gps_coordinate("1600 Amphitheatre Parkway, Mountain View, CA")
print(coordinates)
##Fonction character
# Función específica para obtener pronósticos a partir de direcciones
get_forecast.character <- function(address) {
# Verificar que la entrada sea una cadena de caracteres de tamaño 1
if (!is.character(address) || length(address) != 1) {
stop("L'entrée doit être une chaîne de caractères de taille 1.")
}
# Convertir la dirección en coordenadas GPS utilizando get_gps_coordinate
coordinates <- get_gps_coordinate(address)
# Llamar a get_forecast.numeric con las coordenadas para obtener los pronósticos
return(get_forecast.numeric(coordinates))
}
# Ejemplo de uso
address <- "1600 Amphitheatre Parkway, Mountain View, CA"
forecast_address <- get_forecast.character(address)
print(forecast_address)
#######Fonction numérique
# Función específica para obtener pronósticos a partir de coordenadas GPS
get_forecast.numeric <- function(coordinates) {
# Vérifier que l'entrée est un vecteur numérique de taille 2
if (!is.numeric(coordinates) || length(coordinates) != 2) {
stop("L'entrée doit être un vecteur numérique de taille 2.")
}
# Utiliser perform_request pour interroger une API météo avec les coordonnées
weather_data <- perform_request(coordinates[1], coordinates[2])
# Utiliser unnest_response pour structurer la réponse en un tibble lisible
result <- unnest_data(weather_data)
return(result)
}
coordinates <- c(37.7749, -122.4194)
forecast_coordinates <- get_forecast.numeric(coordinates)
print(forecast_coordinates)
#########Fonction générique
#' Fonction pour obtenir la météo souhaitée
#'
#' @param location
#'
#' @return un dataframe
#' @export
#'
#' @examples get_forecast("Paris")
get_forecast <- function(location) {
UseMethod("get_forecast", location)
}
get_forecast("1600 Amphitheatre Parkway, Mountain View, CA")
coordinates <- c(37.7749, -122.4194)
forecast_coordinates <- get_forecast.numeric(coordinates)
print(forecast_coordinates)
devtools::document()
source("~/olympicsWeather/R/get_weather_forecast.R", echo=TRUE)
devtools::document()
devtools:document()
devtools::document()
rm(list = ls())
devtools::load_all()
devtools::document()
coordinates <- c(37.7749, -122.4194)
forecast_coordinates <- get_forecast.numeric(coordinates)
get_forecast.numeric <- function(coordinates) {
# Vérifier que l'entrée est un vecteur numérique de taille 2
if (!is.numeric(coordinates) || length(coordinates) != 2) {
stop("L'entrée doit être un vecteur numérique de taille 2.")
}
# Utiliser perform_request pour interroger une API météo avec les coordonnées
weather_data <- perform_request(coordinates[1], coordinates[2])
# Utiliser unnest_response pour structurer la réponse en un tibble lisible
result <- unnest_data(weather_data)
return(result)
}
coordinates <- c(37.7749, -122.4194)
forecast_coordinates <- get_forecast.numeric(coordinates)
library(httr2)
library(tibble)
library(tidygeocoder)
url <- "https://api.open-meteo.com/v1/forecast"
request(url) |>
req_url_query(latitude=48.85, longitude=2.35, hourly=c("temperature_2m", "apparent_temperature", "precipitation_probability", "precipitation"), .multi = "comma") |>
req_perform() |> #On exécute la demande
resp_body_json() |>
as_tibble() |>
View()
perform_request <- function(lat, long) {
url <- "https://api.open-meteo.com/v1/forecast"
response_table <-
request(url) |>
req_url_query(latitude=lat, longitude=long, hourly=c("temperature_2m", "apparent_temperature", "precipitation_probability", "precipitation"), .multi="comma") |>
req_perform () |>
resp_body_json() |>
tibble::as.tibble()
return(response_table)
}
resp <- perform_request(48.85, 2.35)
str(resp$hourly[2][[1]], 1)
unlist(resp$hourly[2][[1]], 1)
unnest_data <- function(resp){
tibble(data_heure=unlist(resp$hourly[1][[1]]),
temperature_celsius=unlist(resp$hourly[2][[1]]),
temperature_ressentie_celsius=unlist(resp$hourly[3][[1]]),
precipitation_proba=unlist(resp$hourly[4][[1]]),
precipitation=unlist(resp$hourly[5][[1]]))
}
perform_request(48.85, 3.35) |>  unnest_data() -> y
plot(y$temperature_celsius)
# Función para convertir una dirección en coordenadas GPS
# Definir la función address_to_gps
address_to_gps <- function(location) {
# dataframe temporaire pour utilisation de geocode
df_temp <- data.frame(address = location, stringsAsFactors = FALSE)
# Appel à geocode avec le dataframe temporaire
result <- geocode(
.tbl = df_temp,
address = "address",
method = 'osm',
limit = 1
)
# Vérifie si des coordonnées ont été trouvées
if(nrow(result) > 0 && !is.na(result$lat[1]) && !is.na(result$long[1])) {
return(c(result$lat[1], result$long[1]))
} else {
# Retourne une erreur si aucune coordonnée n'a été trouvée
return("Aucune coordonnée GPS trouvée pour l'adresse fournie.")
}
}
address_to_gps("Paris")
get_forecast <- function(latitude, longitude){
}
get_gps_coordinate <- function(address) {
address_to_gps(address)
}
# Función interna para convertir una dirección en coordenadas GPS
address_to_gps <- function(location) {
# Dataframe temporal para usar con geocode
df_temp <- data.frame(address = location, stringsAsFactors = FALSE)
# Llamada a geocode con el dataframe temporal
result <- geocode(
.tbl = df_temp,
address = "address",
method = 'osm',
limit = 1
)
# Verificar si se encontraron coordenadas
if (nrow(result) > 0 && !is.na(result$lat[1]) && !is.na(result$long[1])) {
return(c(result$lat[1], result$long[1]))
} else {
# Lanzar un error si no se encontraron coordenadas
stop("No se encontraron coordenadas GPS para la dirección proporcionada.")
}
}
# Ejemplo de uso
coordinates <- get_gps_coordinate("1600 Amphitheatre Parkway, Mountain View, CA")
print(coordinates)
##Fonction character
# Función específica para obtener pronósticos a partir de direcciones
#' get_forecast.character
#'
#' @param address
#'
#' @return un dataframe
#' @export
#'
#'
get_forecast.character <- function(address) {
# Verificar que la entrada sea una cadena de caracteres de tamaño 1
if (!is.character(address) || length(address) != 1) {
stop("L'entrée doit être une chaîne de caractères de taille 1.")
}
# Convertir la dirección en coordenadas GPS utilizando get_gps_coordinate
coordinates <- get_gps_coordinate(address)
# Llamar a get_forecast.numeric con las coordenadas para obtener los pronósticos
return(get_forecast.numeric(coordinates))
}
# Ejemplo de uso
address <- "1600 Amphitheatre Parkway, Mountain View, CA"
forecast_address <- get_forecast.character(address)
print(forecast_address)
#######Fonction numérique
# Función específica para obtener pronósticos a partir de coordenadas GPS
#' get_forecast.numeric
#'
#' @param coordinates
#'
#' @return un dataframe
#' @export
#'
#'
get_forecast.numeric <- function(coordinates) {
# Vérifier que l'entrée est un vecteur numérique de taille 2
if (!is.numeric(coordinates) || length(coordinates) != 2) {
stop("L'entrée doit être un vecteur numérique de taille 2.")
}
# Utiliser perform_request pour interroger une API météo avec les coordonnées
weather_data <- perform_request(coordinates[1], coordinates[2])
# Utiliser unnest_response pour structurer la réponse en un tibble lisible
result <- unnest_data(weather_data)
return(result)
}
coordinates <- c(37.7749, -122.4194)
forecast_coordinates <- get_forecast.numeric(coordinates)
print(forecast_coordinates)
#########Fonction générique
#' get_forecast
#'
#' @param location
#'
#' @return un dataframe
#' @export
#'
#' @examples get_forecast("Paris")
get_forecast <- function(location) {
UseMethod("get_forecast", location)
}
get_forecast("1600 Amphitheatre Parkway, Mountain View, CA")
devtools::()
devtools::document()
rm(list = c("get_forecast"))
expect_equal(2 * 2, 4)
rm(list = c("get_forecast"))
devtools::document()
devtools::load_all()
devtools::check()
remotes::install_github('YavaVilar/olympicsWeather')
$ remotes::install_github('YavaVilar/olympicsWeather')
remotes::install_github('YavaVilar/olympicsWeather')
remotes::install_github('YavaVilar/olympicsWeather')
person("Nombre", "Apellido", email = "correo@example.com", role = c("aut", "cre"))
remotes::install_github('YavaVilar/olympicsWeather')
library(httr2)
library(tibble)
library(tidygeocoder)
url <- "https://api.open-meteo.com/v1/forecast"
request(url) |>
req_url_query(latitude=48.85, longitude=2.35, hourly=c("temperature_2m", "apparent_temperature", "precipitation_probability", "precipitation"), .multi = "comma") |>
req_perform() |> #On exécute la demande
resp_body_json() |>
as_tibble() |>
View()
perform_request <- function(lat, long) {
url <- "https://api.open-meteo.com/v1/forecast"
response_table <-
request(url) |>
req_url_query(latitude=lat, longitude=long, hourly=c("temperature_2m", "apparent_temperature", "precipitation_probability", "precipitation"), .multi="comma") |>
req_perform () |>
resp_body_json() |>
tibble::as.tibble()
return(response_table)
}
##8
resp <- perform_request(48.85, 2.35)
str(resp$hourly[2][[1]], 1)
unlist(resp$hourly[2][[1]], 1)
unnest_data <- function(resp){
tibble(data_heure=unlist(resp$hourly[1][[1]]),
temperature_celsius=unlist(resp$hourly[2][[1]]),
temperature_ressentie_celsius=unlist(resp$hourly[3][[1]]),
precipitation_proba=unlist(resp$hourly[4][[1]]),
precipitation=unlist(resp$hourly[5][[1]]))
}
perform_request(48.85, 3.35) |>  unnest_data() -> y
plot(y$temperature_celsius)
##9
usethis::use_test("unnest_response")
data_test <- y[c(1:5),]
library(testthat)
##############question 10#################
# Función para convertir una dirección en coordenadas GPS
# Definir la función address_to_gps
address_to_gps <- function(location) {
# dataframe temporaire pour utilisation de geocode
df_temp <- data.frame(address = location, stringsAsFactors = FALSE)
# Appel à geocode avec le dataframe temporaire
result <- geocode(
.tbl = df_temp,
address = "address",
method = 'osm',
limit = 1
)
# Vérifie si des coordonnées ont été trouvées
if(nrow(result) > 0 && !is.na(result$lat[1]) && !is.na(result$long[1])) {
return(c(result$lat[1], result$long[1]))
} else {
# Retourne une erreur si aucune coordonnée n'a été trouvée
return("Aucune coordonnée GPS trouvée pour l'adresse fournie.")
}
}
address_to_gps("Paris")
get_forecast <- function(latitude, longitude){
}
get_gps_coordinate <- function(address) {
address_to_gps(address)
}
# Función interna para convertir una dirección en coordenadas GPS
address_to_gps <- function(location) {
# Dataframe temporal para usar con geocode
df_temp <- data.frame(address = location, stringsAsFactors = FALSE)
# Llamada a geocode con el dataframe temporal
result <- geocode(
.tbl = df_temp,
address = "address",
method = 'osm',
limit = 1
)
# Verificar si se encontraron coordenadas
if (nrow(result) > 0 && !is.na(result$lat[1]) && !is.na(result$long[1])) {
return(c(result$lat[1], result$long[1]))
} else {
# Lanzar un error si no se encontraron coordenadas
stop("No se encontraron coordenadas GPS para la dirección proporcionada.")
}
}
# Ejemplo de uso
coordinates <- get_gps_coordinate("1600 Amphitheatre Parkway, Mountain View, CA")
print(coordinates)
##Fonction character
# Función específica para obtener pronósticos a partir de direcciones
#' get_forecast.character
#'
#' @param address
#'
#' @return un dataframe
#' @export
#'
#'
get_forecast.character <- function(address) {
# Verificar que la entrada sea una cadena de caracteres de tamaño 1
if (!is.character(address) || length(address) != 1) {
stop("L'entrée doit être une chaîne de caractères de taille 1.")
}
# Convertir la dirección en coordenadas GPS utilizando get_gps_coordinate
coordinates <- get_gps_coordinate(address)
# Llamar a get_forecast.numeric con las coordenadas para obtener los pronósticos
return(get_forecast.numeric(coordinates))
}
# Ejemplo de uso
address <- "1600 Amphitheatre Parkway, Mountain View, CA"
forecast_address <- get_forecast.character(address)
View(data_test)
View(resp)
View(y)
get_forecast.numeric <- function(coordinates) {
# Vérifier que l'entrée est un vecteur numérique de taille 2
if (!is.numeric(coordinates) || length(coordinates) != 2) {
stop("L'entrée doit être un vecteur numérique de taille 2.")
}
# Utiliser perform_request pour interroger une API météo avec les coordonnées
weather_data <- perform_request(coordinates[1], coordinates[2])
# Utiliser unnest_response pour structurer la réponse en un tibble lisible
result <- unnest_data(weather_data)
return(result)
}
coordinates <- c(37.7749, -122.4194)
forecast_coordinates <- get_forecast.numeric(coordinates)
print(forecast_coordinates)
remotes::install_github('YavaVilar/olympicsWeather')
remotes::install_github('YavaVilar/olympicsWeather')
remotes::install_github('YavaVilar/olympicsWeather')
?person()
remotes::install_github('YavaVilar/olympicsWeather')
data <- read.csv("C:/Users/yavav/Downloads/ICPMS Raw data.csv")
colnames(data)
saumons <- data[,c(1,2,4,7,13:20,23:27,28,30,31,33)]
colnames(saumons) <-c("Class","Li", "B", "Al", "V", "Cr", "Mn", "Fe", "Co", "Ni", "Cu", "Zn", "As", "Se", "Rb", "Sr", "Nb", "Mo", "Cd", "Cs", "Ta")
colnames(saumons)
View(saumons)
library(caret)
process <- preProcess(as.data.frame(saumons), method=c("range"))
saumons<- predict(process, as.data.frame(saumons))
str(saumons)
library(tidyverse)
library(ggplot2)
vecteur_couleurs <- c("Alaskan" = "lightblue", "Norway"="red", "Scotland"="darkblue", "Iceland-W"="lightgreen", "Iceland-F"="yellow")
saumons |>
ggplot() +
aes(x = fct_infreq(Class),fill=Class) +
geom_bar() +
scale_fill_manual(values=vecteur_couleurs) +
ggtitle("Répartition des saumons par pays") +
labs(x="Pays", y="Effectif")+
theme_classic() +
theme(plot.title = element_text(hjust = 0.5, size = 12))
summary(select_if(saumons, is.numeric))
library(ggplot2)
library(tidyverse)
saumons|>
pivot_longer(
cols = where(is.numeric)
) |>
ggplot() +
aes(y = value) +
facet_wrap(~ name, scales = "free_y") +
geom_boxplot() +
theme_light()
dim(saumons)
library(gridExtra)
ggp<-list()
for (i in 1:ncol(saumons)){
ggp[[i]] <- ggplot(saumons, aes(x = .data[[names(saumons)[i]]])) +
geom_histogram()
}
grid.arrange(grobs=ggp)
n=nrow(saumons)
p=ncol(saumons)-1
set.seed(123)
saumons[,1] <- as.factor(saumons[,1])
table(saumons$Class)
intrain<-createDataPartition(saumons$Class,p=0.8,list=FALSE)
intrain
X.app <- saumons[intrain,-1]
Y.app <- saumons[intrain,1]
X.test <- saumons[-intrain,-1]
Y.test <- saumons[-intrain,1]
library(mixOmics)
plsda.saumons <- mixOmics::plsda(X.app,Y.app,ncomp = min(n-1,p), scale=TRUE) #scale=TRUE, dispersion importante au sein des variables
help(plsda)
plotVar(plsda.saumons,comp = 1:2)
plotIndiv(plsda.saumons, comp = 1:2,centroid = TRUE,ellipse = TRUE, legend = TRUE)
perf.saumons <- perf(plsda.saumons,validation = "Mfold", folds = 5,
progressBar = FALSE, auc = TRUE, nrepeat = 20)
View(perf.saumons)
plot(perf.saumons, measure="overall")
#regarder min de max.dist => 5
#confirmé par la fonction automatique suivante
perf.saumons$choice.ncomp
perf.saumons <- perf(plsda.saumons,validation = "Mfold", folds = 5,
progressBar = FALSE, auc = TRUE, nrepeat = 5)
View(perf.saumons)
plot(perf.saumons, measure="overall")
plot(perf.saumons, measure="overall")
#regarder min de max.dist => 5
#confirmé par la fonction automatique suivante
perf.saumons$choice.ncomp
plot(perf.saumons, measure="overall")
nb_comp=perf.saumons$choice.ncomp[1,1]
perf.saumons$error.rate
vip.saumons <- vip(plsda.saumons)[,nb_comp]
vip.saumons
barplot(vip.saumons, xlab=colnames(X.app), las=2)
abline(h=1,col="red")
auc.saumons <- auroc(plsda.saumons,roc.comp = nb_comp)
plsda.fin.saumons <- plsda(X.app,Y.app, ncomp = nb_comp, scale=TRUE)
plsda.test <- predict(plsda.fin.saumons, dist ="max.dist", newdata = X.test)
plsda.test
mat.confusion <- table(Y.test,plsda.test$class$max.dist[,nb_comp]) #matrice de confusion
mat.confusion
sum(diag(mat.confusion))/sum(mat.confusion) #taux de précision
plsda.fin.saumons
1-sum(diag(mat.confusion))/sum(mat.confusion) #taux d'erreur
auc.saumons <- auroc(plsda.saumons_1,roc.comp = 5)
auc.saumons <- auroc(plsda.saumons,roc.comp = 5)
